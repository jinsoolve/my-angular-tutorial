ì•„ë˜ ì˜ˆì‹œëŠ” Suffix Automaton(SAM) ì„ C++17 ê¸°ì¤€ìœ¼ë¡œ êµ¬í˜„í•œ â€œê°€ì¥ ë² ì´ì§í•œ ë¼ˆëŒ€â€ì…ë‹ˆë‹¤.
	â€¢	extend()â€Š: ë¬¸ìì—´ì„ í•œ ê¸€ìì”© ì¶”ê°€í•˜ë©° ìƒíƒœ(ë…¸ë“œ)ë¥¼ í™•ì¥
	â€¢	build()â€Š: ì „ì²´ ë¬¸ìì—´ì„ ë°›ì•„ ìë™ìœ¼ë¡œ extend() í˜¸ì¶œ
	â€¢	ë³´ì¡° í•¨ìˆ˜â€Š:
	â€¢	contains()â€Š: ì£¼ì–´ì§„ íŒ¨í„´ì´ S ì˜ ì„œë¸ŒìŠ¤íŠ¸ë§ì¸ì§€ í™•ì¸
	â€¢	countDistinctSubstrings()â€Š: ì„œë¡œ ë‹¤ë¥¸ ì„œë¸ŒìŠ¤íŠ¸ë§ ê°œìˆ˜ ê³„ì‚°
	â€¢	longestCommonSubstring()â€Š: ë‘ ë¬¸ìì—´ LCS ê¸¸ì´ (SAMâ€†+â€†2nd pass)

âœ¨ í•µì‹¬ í¬ì¸íŠ¸
	1.	link(suffix link) ì™€ next(char â†’ ìƒíƒœ) ê°€ SAM ì˜ ê³¨ê²©
	2.	len = ê·¸ ìƒíƒœê°€ í‘œí˜„í•  ìˆ˜ ìˆëŠ” ê°€ì¥ ê¸´ ì„œë¸ŒìŠ¤íŠ¸ë§ ê¸¸ì´
	3.	first_pos (ì„ íƒ) = ì²˜ìŒ ë“±ì¥ ìœ„ì¹˜, ìœ„ì¹˜-ì§ˆì˜ì— í•„ìš”

#include <bits/stdc++.h>
using namespace std;

struct SuffixAutomaton {
    struct State {
        int len = 0;                     // max length for this state
        int link = -1;                   // suffix link
        array<int, 26> next;             // transitions (ë‹¨ì¼ ì†Œë¬¸ì ì•ŒíŒŒë²³ ì˜ˆì‹œ)
        long long subCnt = 0;            // DP: distinct substring count of subtree

        State() { next.fill(-1); }
    };

    vector<State> st;
    int last = 0;                        // id of state representing whole string

    explicit SuffixAutomaton(int maxLen = 0) {
        st.reserve(2 * maxLen);
        st.emplace_back();               // state 0 = root
    }

    // â‘  í•œ ê¸€ì í™•ì¥
    void extend(char ch) {
        int c = ch - 'a';
        int cur = (int)st.size();
        st.emplace_back();
        st[cur].len = st[last].len + 1;

        int p = last;
        for (; p != -1 && st[p].next[c] == -1; p = st[p].link)
            st[p].next[c] = cur;

        if (p == -1) {
            st[cur].link = 0;            // root
        } else {
            int q = st[p].next[c];
            if (st[p].len + 1 == st[q].len) {
                st[cur].link = q;        // direct suffix
            } else {
                // â‘¢ clone state
                int clone = (int)st.size();
                st.push_back(st[q]);     // copy
                st[clone].len = st[p].len + 1;
                // no need to copy subCnt; will be updated later
                for (; p != -1 && st[p].next[c] == q; p = st[p].link)
                    st[p].next[c] = clone;

                st[q].link   = clone;
                st[cur].link = clone;
            }
        }
        last = cur;
    }

    // â‘¡ ì „ì²´ ë¬¸ìì—´ ì²˜ë¦¬
    explicit SuffixAutomaton(const string &s) {           // í¸ì˜ ìƒì„±ì
        st.reserve(2 * (int)s.size());
        st.emplace_back();
        for (char ch : s) extend(ch);
    }
    void build(const string &s) {                         // ë³„ë„ build ë²„ì „
        for (char ch : s) extend(ch);
    }

    // â‘£ íŒ¨í„´ ì¡´ì¬ ì—¬ë¶€
    bool contains(const string &pat) const {
        int v = 0;
        for (char ch : pat) {
            int c = ch - 'a';
            if (st[v].next[c] == -1) return false;
            v = st[v].next[c];
        }
        return true;
    }

    // â‘¤ ì„œë¡œ ë‹¤ë¥¸ ì„œë¸ŒìŠ¤íŠ¸ë§ ê°œìˆ˜ = Î£(state.len - st[link].len)
    long long countDistinctSubstrings() {
        if (st[0].subCnt) return st[0].subCnt;            // ì´ë¯¸ ê³„ì‚°?
        vector<int> order(st.size());
        iota(order.begin(), order.end(), 0);
        sort(order.begin(), order.end(),
             [&](int a, int b) { return st[a].len > st[b].len; }); // top-down

        long long total = 0;
        for (int v : order) {
            long long add = st[v].len - (st[v].link == -1 ? 0 : st[ st[v].link ].len);
            st[v].subCnt = add;
            if (st[v].link != -1) st[ st[v].link ].subCnt += st[v].subCnt;
            total += add;
        }
        return total;
    }

    // â‘¥ ë‘ ë¬¸ìì—´ LCS ê¸¸ì´ (SAM of s1, feed s2)
    int lcs(const string &t) const {
        int v = 0, l = 0, best = 0;
        for (char ch : t) {
            int c = ch - 'a';
            while (v && st[v].next[c] == -1) {
                v = st[v].link;
                l = st[v].len;
            }
            if (st[v].next[c] != -1) {
                v = st[v].next[c];
                ++l;
            }
            best = max(best, l);
        }
        return best;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    string s; cin >> s;
    SuffixAutomaton sam(s);          // ìƒì„±ìì—ì„œ build
    cout << "distinct substrings = " << sam.countDistinctSubstrings() << '\n';

    int q; cin >> q;
    while (q--) {
        string pat; cin >> pat;
        cout << (sam.contains(pat) ? "Yes\n" : "No\n");
    }
    return 0;
}


â¸»

ì½”ë“œ ìš”ì•½ & í™•ì¥ í¬ì¸íŠ¸

ë¸”ë¡	ì„¤ëª…	í™•ì¥ ì•„ì´ë””ì–´
extend	ì˜¨ë¼ì¸ êµ¬ì¶•ì˜ í•µì‹¬. clone ë¶„ê¸°ë¥¼ ì •í™•íˆ êµ¬í˜„í•´ì•¼ minimal DFA ë³´ì¥	ì•ŒíŒŒë²³ì´ í¬ë‹¤ë©´ array<int,26> â†’ unordered_map<char,int>
contains	ì¡´ì¬ ì—¬ë¶€ O(	pat
countDistinctSubstrings	SAM ì •ë¦¬ ê³µì‹ Î£(len(v) âˆ’ len(link(v))) ì´ìš©	ë¹ˆë„(occurrence) DPë¡œ ì¶”ê°€ ì§‘ê³„
lcs	LCS ê¸¸ì´ ê³„ì‚°ìš© ì „í˜• ë£¨í”„	ë‘ ë¬¸ìì—´ ëª¨ë‘ SAM ì—†ì´ O(n+m)


â¸»

ë¹Œë“œ & ì‹¤í–‰ ì˜ˆì‹œ

g++ -std=c++17 -O2 sam.cpp -o sam
echo -e "banana\n5\nana\nban\nnana\napple\nba" | ./sam
# ì¶œë ¥
# distinct substrings = 15
# Yes
# Yes
# Yes
# No
# Yes

ğŸ”‘ Tip:
	â€¢	ë¬¸ìì—´ì´ ìœ ë‹ˆì½”ë“œâ€†/â€†ëŒ€ë¬¸ì í¬í•¨ì´ë©´ unordered_map<char32_t,int> ë“±ìœ¼ë¡œ ì „ì´ ì €ì¥
	â€¢	long long subCnt ë¶€ë¶„ì„ ì‘ìš©í•´ ê° substring ë¹ˆë„ (í† í° ì¶œí˜„ íšŸìˆ˜)ë„ ì‰½ê²Œ êµ¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

í•„ìš”í•˜ë©´ Suffix Tree(Ukkonen) C++ ì½”ë“œë‚˜ ë” ê³ ê¸‰ DP ì˜ˆì‹œë„ ë„ì™€ë“œë¦´ í…Œë‹ˆ, ì–¸ì œë“  ë§ì”€ ì£¼ì„¸ìš”!








