좋아요! 주어진 조건을 정리하면 다음과 같습니다:

⸻

✅ 조건 정리
	•	fetchedKeywords: Set<SearchKeyword>
→ SearchKeyword는 { id: string; keyword: string } 형식일 것으로 가정
	•	거기서 랜덤한 값을 하나 꺼내서
	•	SearchStrategy 객체의 getFilteredItems(query: string) 호출

⸻

✅ 예시 코드

function testRandomQueryFromFetchedKeywords(
  fetchedKeywords: Set<{ id: string; keyword: string }>,
  strategy: { getFilteredItems: (query: string) => any }
): void {
  if (fetchedKeywords.size === 0) {
    console.warn('🚨 fetchedKeywords가 비어 있습니다.');
    return;
  }

  // Set을 Array로 변환해서 랜덤하게 하나 선택
  const keywordsArray = Array.from(fetchedKeywords);
  const randomIndex = Math.floor(Math.random() * keywordsArray.length);
  const randomKeyword = keywordsArray[randomIndex].keyword;

  // SearchStrategy 실행
  const results = strategy.getFilteredItems(randomKeyword);

  // 결과 출력
  console.log(`🔍 Random query: "${randomKeyword}"`);
  console.log('📦 검색 결과:', results);
}


⸻

✅ 사용 예

import { NaiveSearchStrategy } from './strategies/naive-search-strategy';

const fetchedKeywords = new Set([
  { id: 'kw-001', keyword: 'light' },
  { id: 'kw-002', keyword: '조명' },
  { id: 'kw-003', keyword: '전등' }
]);

const strategy = new NaiveSearchStrategy(flatData); // 이미 구현되어 있다고 가정

testRandomQueryFromFetchedKeywords(fetchedKeywords, strategy);


⸻

🧠 보너스: 반복 실행 및 평균 측정 포함?

원하면 runNTests(n: number) 같은 걸로 N번 반복하며 평균 성능 측정도 같이 해드릴 수 있어요.

필요하면 다음 단계로 확장해드릴게요.
지금은 위 함수로 랜덤 호출만 하는 구조에 집중했어요!