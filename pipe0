좋습니다!
이제 Set<SearchKeyword>에서 여러 개의 랜덤 keyword를 선택해서,
각각에 대해 SearchStrategy.getFilteredItems(query)를 호출하고 싶다는 거죠?

⸻

✅ 목표
	•	Set<SearchKeyword>에서 N개 랜덤 추출
	•	각 keyword로 getFilteredItems(keyword) 실행
	•	결과 및 시간 측정 (옵션)

⸻

✅ 함수 코드: N개 랜덤 추출 후 전략 호출

function testMultipleRandomQueriesFromFetchedKeywords(
  fetchedKeywords: Set<{ id: string; keyword: string }>,
  strategy: { getFilteredItems: (query: string) => any },
  count: number
): void {
  const keywordsArray = Array.from(fetchedKeywords);

  if (keywordsArray.length < count) {
    console.warn(`❗ 요청한 개수(${count})가 Set 크기(${keywordsArray.length})보다 큽니다.`);
    count = keywordsArray.length;
  }

  // ✅ Fisher-Yates 셔플로 랜덤한 N개 추출
  for (let i = keywordsArray.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [keywordsArray[i], keywordsArray[j]] = [keywordsArray[j], keywordsArray[i]];
  }
  const selected = keywordsArray.slice(0, count);

  // ✅ 각 keyword로 검색 실행
  for (const kw of selected) {
    const start = performance.now();
    const result = strategy.getFilteredItems(kw.keyword);
    const end = performance.now();

    console.log(`🔍 '${kw.keyword}' → ${result.length}개 결과`);
    console.log(`⏱️ ${end - start}ms`);
  }
}


⸻

✅ 사용 예

testMultipleRandomQueriesFromFetchedKeywords(fetchedKeywords, strategy, 5);

위 코드는 Set에서 랜덤하게 5개 keyword를 뽑아 순차적으로 검색을 실행하고,
각 결과 수와 걸린 시간도 출력합니다.

⸻

✅ 필요시 평균 시간 계산 포함?

원하면 아래처럼 평균 시간도 넣을 수 있어요:

let totalTime = 0;

for (const kw of selected) {
  const start = performance.now();
  const result = strategy.getFilteredItems(kw.keyword);
  const end = performance.now();
  totalTime += (end - start);
}
console.log(`📊 평균 시간: ${(totalTime / count).toFixed(2)}ms`);


⸻

필요하면 suffixTrie, naive 등을 비교하는 버전도 통합해드릴 수 있어요.
지금 단계에서는 이 코드로 충분히 테스트할 수 있습니다.