@Injectable({ providedIn: 'root' })
export class SearchDBService {
  private _items: SearchItem[] = [];
  private _items$ = new BehaviorSubject<SearchItem[]>([]);
  public readonly items$ = this._items$.asObservable();

  constructor() {
    this.loadItems();
  }

  private async loadItems() {
    const staticData = await fetch('/assets/json/search-items.json').then(res => res.json()) as SearchItem[];
    const visitData = this.loadVisitData(); // localStorage에서 기록 가져오기

    const merged = staticData.map(item => ({
      ...item,
      visitCount: visitData[item.id]?.visitCount ?? 0,
      recentVisit: visitData[item.id]?.recentVisit ?? 0
    }));

    this._items = merged;
    this._items$.next(this._items);
  }

  updateVisit(id: string): void {
    const item = this._items.find(i => i.id === id);
    if (!item) return;

    item.visitCount = (item.visitCount ?? 0) + 1;
    item.recentVisit = Date.now();

    this._items$.next(this._items);
    this.saveVisitData();
  }

  private loadVisitData(): Record<string, { visitCount: number; recentVisit: number }> {
    try {
      return JSON.parse(localStorage.getItem('searchVisitData') ?? '{}');
    } catch {
      return {};
    }
  }

  private saveVisitData() {
    const visitData: Record<string, { visitCount: number; recentVisit: number }> = {};

    for (const item of this._items) {
      visitData[item.id] = {
        visitCount: item.visitCount ?? 0,
        recentVisit: item.recentVisit ?? 0
      };
    }

    localStorage.setItem('searchVisitData', JSON.stringify(visitData));
  }

  // Optional: 랭킹, 히스토리용 stream도 추가 가능
}